import sqlalchemy
import os
import dotenv
from faker import Faker
import numpy as np
from sqlalchemy import create_engine

def database_connection_url():
    dotenv.load_dotenv()
    return os.environ.get("POSTGRES_URI")

engine = create_engine(database_connection_url(), pool_pre_ping=True)

# Create a new DB engine based on our connection string
engine = sqlalchemy.create_engine(database_connection_url(), use_insertmanyvalues=True)

with engine.begin() as conn:
    conn.execute(sqlalchemy.text("""
    DROP TABLE IF EXISTS room CASCADE;
    DROP TABLE IF EXISTS users CASCADE;
    DROP TABLE IF EXISTS event CASCADE;
    DROP TABLE IF EXISTS calendar CASCADE;
    DROP TABLE IF EXISTS chores CASCADE;
    DROP TABLE IF EXISTS split CASCADE;

    CREATE TABLE
    calendar (
        id bigint generated by default as identity,
        created_at timestamp with time zone not null default now(),
        name text null,
        constraint Calendar_pkey primary key (id)
    );

    CREATE TABLE
    room (
        id bigint generated by default as identity,
        created_at timestamp with time zone not null default now(),
        calendar_id bigint null,
        room_name text not null,
        constraint Room_pkey primary key (id),
        constraint room_calendar_id_fkey foreign key (calendar_id) references calendar (id)
    );

    CREATE TABLE
    users (
        id bigint generated by default as identity,
        created_at timestamp with time zone not null default now(),
        name text not null,
        room_id bigint null,
        points integer null default 0,
        calendar_id bigint null,
        constraint Users_pkey primary key (id),
        constraint users_calendar_id_fkey foreign key (calendar_id) references calendar (id),
        constraint users_room_id_fkey foreign key (room_id) references room (id)
    );

    CREATE TABLE
    event (
        id bigint generated by default as identity,
        name text not null,
        start_time timestamp with time zone null,
        end_time timestamp with time zone null,
        calendar_id bigint null,
        description text null,
        constraint Event_pkey primary key (id),
        constraint event_calendar_id_fkey foreign key (calendar_id) references calendar (id)
    );

    CREATE TABLE
    chores (
        id bigint generated by default as identity,
        created_at timestamp with time zone not null default now(),
        chore_name text not null,
        assigned_user_id bigint null,
        completed boolean not null default false,
        points integer null,
        completed_at timestamp with time zone null,
        constraint chores_pkey primary key (id),
        constraint chores_assigned_user_id_fkey foreign key (assigned_user_id) references users (id)
    );

    CREATE TABLE
    split (
        id bigint generated by default as identity,
        created_at timestamp with time zone not null default now(),
        name text null,
        price real null,
        quantity integer null,
        user_added bigint null,
        constraint split_pkey primary key (id),
        constraint split_user_added_fkey foreign key (user_added) references users (id)
    );
    """))

# 50k rooms, 50k + 50k (1/4 users) calendars, 200k users - 350k
# 150k events (1 per room + 2 per user calendar), 200k chores (1 per user), 300k splits (2 per non-calendar user))

fake = Faker()
num_rooms = 50000

with engine.begin() as conn:
    for i in range(1, num_rooms + 1):
        print(i)
        # calendar
        result = conn.execute(sqlalchemy.text("""
            INSERT INTO calendar (name) VALUES (:name) RETURNING id;
        """), {"name": "Room " + str(i) + " calendar"})
        calendar_id = result.fetchone()[0]

        # event
        conn.execute(sqlalchemy.text("""
            INSERT INTO event (name, calendar_id, start_time, end_time) VALUES (:name, :calendar_id, now(), now() + interval '1 hour');
        """), {"name": "Room " + str(i) + "'s event", "calendar_id": calendar_id})

        # room
        result = conn.execute(sqlalchemy.text("""
            INSERT INTO room (room_name, calendar_id) VALUES (:room_name, :calendar_id) RETURNING id;
        """), {"room_name": "Room " + str(i), "calendar_id": calendar_id})
        room_id = result.fetchone()[0]

        # users
        for j in range(1, 5):
            user_id = (i - 1) * 4 + j
            name = fake.name()
            event_name = fake.catch_phrase()
            event_name2 = fake.catch_phrase()
            if j == 1:
                # 1/4 users get a private calendar and 2 events
                # calendar
                res = conn.execute(sqlalchemy.text("""
                    INSERT INTO calendar (name) VALUES (:name) RETURNING id;
                """), {"name": name + "'s calendar"})
                calendar_id2 = res.fetchone()[0]

                #event
                conn.execute(sqlalchemy.text("""
                    INSERT INTO event (name, calendar_id, start_time, end_time) VALUES (:name, :calendar_id, now(), now() + interval '1 hour');
                """), {"name": event_name, "calendar_id": calendar_id2})

                conn.execute(sqlalchemy.text("""
                    INSERT INTO event (name, calendar_id, start_time, end_time) VALUES (:name, :calendar_id, now(), now() + interval '1 hour');
                """), {"name": event_name2, "calendar_id": calendar_id2})

                # users
                res = conn.execute(sqlalchemy.text("""
                    INSERT INTO users (name, room_id, points, calendar_id) VALUES (:name, :room_id, :points, :calendar_id) RETURNING id;
                """), {"name": name, "room_id": room_id, "calendar_id": calendar_id2, "points": np.random.randint(0, 10)})
                user_id = res.fetchone()[0]
            else:
                # users
                res = conn.execute(sqlalchemy.text("""
                    INSERT INTO users (name, room_id, points) VALUES (:name, :room_id, :points) RETURNING id;
                """), {"name": name, "room_id": room_id, "points": np.random.randint(0, 10)})
                user_id = res.fetchone()[0]

                # splits
                groceries = [
                    "Milk", "Bread", "Eggs", "Cheese", "Apples", "Bananas", "Chicken", "Rice", "Pasta", "Tomatoes",
                    "Potatoes", "Onions", "Carrots", "Spinach", "Broccoli", "Yogurt", "Cereal", "Coffee", "Tea",
                    "Orange Juice", "Peanut Butter", "Jelly/Jam", "Olive Oil", "Vinegar", "Honey", "Flour", "Sugar",
                    "Salt", "Pepper", "Canned Beans", "Canned Tuna", "Canned Soup", "Frozen Vegetables", "Frozen Pizza",
                    "Frozen Fruits", "Bread Rolls", "Lettuce", "Bell Peppers", "Avocados", "Grapes", "Strawberries",
                    "Blueberries", "Pineapple", "Watermelon", "Cauliflower", "Milk Alternatives", "Quinoa", "Nuts",
                    "Oatmeal", "Sliced Ham or Turkey"
                ]
                conn.execute(sqlalchemy.text("""
                    INSERT INTO split (name, price, quantity, user_added) VALUES (:name, :price, :quantity, :user_added);
                """), {"name": np.random.choice(groceries), "price": np.random.randint(5, 20), "quantity": np.random.randint(1, 5), "user_added": user_id})
                conn.execute(sqlalchemy.text("""
                    INSERT INTO split (name, price, quantity, user_added) VALUES (:name, :price, :quantity, :user_added);
                """), {"name": np.random.choice(groceries), "price": np.random.randint(5, 20), "quantity": np.random.randint(1, 5), "user_added": user_id})

            # chores
            conn.execute(sqlalchemy.text("""
                INSERT INTO chores (chore_name, assigned_user_id, completed, points) VALUES (:chore_name, :assigned_user_id, :completed, :points);
            """), {"chore_name": fake.catch_phrase(), "assigned_user_id": user_id, "completed": fake.pybool(), "points": np.random.randint(1, 5) * 5})